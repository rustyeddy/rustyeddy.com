---
title: Goals
draft: true
date: 2024-10-06
---

### Goals are Most Effective When ...

Goals do not have to be obnoxious, obtuse, vague or
pendantic. Just be real and reasonable.

If you want working software, provide a working set of goals.

- Few in number, very targeted
- Communicated in normal people language (user stories)
- Provide users quick and immediate value
- Prioritized to deliver _usable value_ incrementally
- Measurable and easy to determine when they are complete
- Everybody understands and agrees with the Goals
- Tasks should be 1-3 days max if possible (there will always be exceptions)

All these tasks have to add up to the MVP. Anything that does not
directly and immediately get the software project closer to an MVP
must be avoided.

### Start A Specific and Measureable Goal

It is surprising how many software project get underway without a
clear direction to what they are building.

> Do NOT build a house before you have approved architectural
> drawings.

The above statement should be self evident. The same applies to
software.

### Define Good Goals

Good goals keep everybody focused and working toward the same
endpoint. They must not be 

1. Singular: have a single requirement. Do not confuse the issue with
   second and third level concerns
2. They are easy to understand to everybody is always on the same page
3. Goals must be measurable, you have to be able to tell when they are
   done, or how well they are working.
4. Realistic: do not make people feel like the must continually be
   superwoman.

### Tasks Are Small and Measurable 

The tasks that we come up with must be completed within a day or
two. Any task that requires three days or more should probably be
broken down into smaller bite-size tasks.

We do not want to create tasks so that they're too big, ambiguous or
subject to misinterpretation. If your team is not making progress in a
day or two you should be able to know that immediately.

Keeping the granularity of tasks small allows the team to _start
stacking victories quickly_ and more important, gives everybody a
chance to see when a software project is about to make a left turn.

