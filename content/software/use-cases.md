---
title: Use Cases
description: >
  We are going to dig deep into our users needs and observe how they
  want to use the software, this will ultimately lead us to our
  MVP. We will define this in terms of Use Cases.
weight: 20
---

{{< draft >}}
## References Definition of Use Case

### [Wrike](https://www.wrike.com/blog/what-is-a-use-case)

> A use case is a concept used in software development, product
> design, and other fields to describe how a system can be used to
> achieve specific goals or tasks. It outlines the interactions between
> users or actors and the system to achieve a specific outcome.  


### [Ivar Jacobson](https://www.ivarjacobson.com/publications/articles/use-cases-ultimate-guide)




## Outline

### Wrike website above

1. Defines the various ways users will use the software

2. Can and should establish success and failure scenarios

3. First article on Use Cases was established by Swedish computer
   scientist Ivar Jacobson in 1987 originally used by
   telecommunications company Ericsson to capture system
   requirements. 
   
4. In 1992 Jacobson co-authored the book "Object-Oriented Software
   Engineering - A Use Case Driven Approach" to help specifying
   functional requirements in Software Development

5. Use cases capture all of the uses of a software system which in
   totality define the full set of requirements for the system.
   
6. Use cases define particular features that can be define in an
   incremental fashion and developed using _agile_ methodologies.


## Customer Discovery

_Customer Discovery_ consists of one or more customer discovery
sessions, where all *users* and *owners* of the software will be
interviewed for their expectations, needs and desires for the
upcoming software project. 

Don't just stop at the first answer, it will be too vague. Dig deeper
and start peeling back the details. This great article on the
[Five Why's](https://www.mindtools.com/pages/article/newTMC_5W.htm)

## User Stories

The information gathered from these sessions are then articulated in a
series of _non-technical_ descriptions of how the software is used by
everybody.

These descriptions of the software requirements are often referred to
as _User Stories_. Basically, each _story_ walks through one of the
ways in which the _planned_ software will be used.

### Keep Language Plain

The project can be discussed and understood best when the conversation
is had in terms that the user is comfortable with.

It is important to keep the language common and avoid tech talk such
that _everybody_ involved with the building and using the software can
participate in the conversation.

These user stories will later get broken down into specific tasks.

The real value to user stories is to create them like they are
recipes. Essentially software is about writing recipes with very
specific rules.   

## The Good 'ol Minimum Viable Product (MVP)

An important result of the customer discovery session is a mutual
agreement on what the minimum or useful (viable) piece of software is and 
which can be delivered as soon as possible.

The primary purpose of the MVP is to get stuff out the door. We
specifically want to avoid _disconnected development teams_.

Software can be properly managed just like  construction project. That's only if the right processes and tools are established and enforced
throughout the product lifecycle.

> Read The [Lean Startup](http://theleanstartup.com/) to really understand how to get specific about building a product your target market will be crazy about.

This is an involved and very important topic. I'm not going to attempt to
repeat or summarize them in this document, but we will assume that we
have a pretty clear picture of the application we are developing, at
least enough for now.

## Tasks Are Small and Measurable 

The tasks that we come up with must be completed within a day or
two. Any task that requires three days or more should probably be
broken down into smaller bite-size tasks.

We do not want to create tasks so that they're too big, ambiguous or
subject to misinterpretation. If your team is not making progress in a
day or two you should be able to know that immediately.

Keeping the granularity of tasks small allows the team to _start
stacking victories quickly_ and more important, gives everybody a
chance to see when a software project is about to make a left turn.


### Goals are Most Effective When ...

Goals do not have to be obnoxious, obtuse, vague or
pendantic. Just be real and reasonable.

If you want working software, provide a working set of goals.

- Few in number, very targeted
- Communicated in normal people language (user stories)
- Provide users quick and immediate value
- Prioritized to deliver _usable value_ incrementally
- Measurable and easy to determine when they are complete
- Everybody understands and agrees with the Goals
- Tasks should be 1-3 days max if possible (there will always be exceptions)

All these tasks have to add up to the MVP. Anything that does not
directly and immediately get the software project closer to an MVP
must be avoided.
{{</draft>}}


{{<draft>}}


### Start A Specific and Measureable Goal

It is surprising how many software project get underway without a
clear direction to what they are building.

> Do NOT build a house before you have approved architectural
> drawings.

The above statement should be self evident. The same applies to
software.

### Define Good Goals

Good goals keep everybody focused and working toward the same
endpoint. They must not be 

1. Singular: have a single requirement. Do not confuse the issue with
   second and third level concerns
2. They are easy to understand to everybody is always on the same page
3. Goals must be measurable, you have to be able to tell when they are
   done, or how well they are working.
4. Realistic: do not make people feel like the must continually be
   superwoman.

{{</draft>}}
